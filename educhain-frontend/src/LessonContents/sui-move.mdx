# Introduction to Sui Move Programming

Welcome to the comprehensive guide to Sui Move programming! This lesson will take you from the basics of Move to advanced Sui-specific concepts.

## What is Move?

Move is a safe and secure programming language designed specifically for blockchain smart contracts. It was originally developed by Facebook (now Meta) for their Diem blockchain project, and has been adopted by Sui as its primary smart contract language.

### Key Features of Move

- **Resource-oriented**: Move treats digital assets as resources that cannot be copied or implicitly discarded
- **Type safety**: Strong static typing prevents common programming errors
- **Formal verification**: Designed to be mathematically verifiable
- **Modular**: Clean separation between modules and scripts

## Sui Move vs. Other Move Implementations

While Move was originally designed for Diem, Sui has made several enhancements:

- **Object Model**: Sui uses an object-based model instead of accounts
- **Shared Objects**: Ability to create objects that can be accessed by multiple parties
- **Dynamic Fields**: Flexible key-value storage on objects
- **Enhanced Events**: Rich event system for off-chain indexing

## Basic Move Syntax

### Modules and Functions

```move
module my_module_addr::my_module {

    // Use statements
    use std::string::{Self, String};
    use sui::object::{Self, UID};
    use sui::tx_context::TxContext;

    // Struct definitions
    public struct MyStruct has key, store {
        id: UID,
        value: u64,
    }

    // Function definitions
    public entry fun create_my_struct(value: u64, ctx: &mut TxContext) {
        let my_struct = MyStruct {
            id: object::new(ctx),
            value,
        };
        transfer::transfer(my_struct, tx_context::sender(ctx));
    }

    public fun get_value(my_struct: &MyStruct): u64 {
        my_struct.value
    }
}
```

### Key Concepts

### 1. Abilities

Move uses **abilities** to define what operations can be performed on types:

- `copy`: Can be copied
- `drop`: Can be discarded
- `store`: Can be stored in global storage
- `key`: Can be used as a key in global storage

```move
// This struct can be stored and used as a key
public struct Item has key, store {
    id: UID,
    name: String,
}

// This struct can only be used locally (cannot be stored)
public struct TemporaryData has drop {
    temp_value: u64,
}
```

### 2. Ownership and Borrowing

```move
public entry fun update_value(
    my_struct: &mut MyStruct,
    new_value: u64,
    _ctx: &mut TxContext
) {
    // Mutable borrow allows modification
    my_struct.value = new_value;
}

public fun read_value(my_struct: &MyStruct): u64 {
    // Immutable borrow allows reading
    my_struct.value
}
```

## Sui-Specific Features

### Objects and UID

In Sui, everything is an object with a unique identifier:

```move
use sui::object::{Self, UID};
use sui::tx_context::TxContext;

public struct MyObject has key, store {
    id: UID,
    data: String,
}

public entry fun create_object(data: String, ctx: &mut TxContext) {
    let obj = MyObject {
        id: object::new(ctx),
        data,
    };
    transfer::transfer(obj, tx_context::sender(ctx));
}
```

### Shared Objects

Shared objects can be accessed by anyone:

```move
public entry fun share_object(data: String, ctx: &mut TxContext) {
    let obj = MyObject {
        id: object::new(ctx),
        data,
    };
    transfer::public_share_object(obj);
}
```

### Dynamic Fields

Add flexible key-value storage to objects:

```move
use sui::dynamic_field as df;

public entry fun add_field(
    obj: &mut MyObject,
    key: String,
    value: u64,
    _ctx: &mut TxContext
) {
    df::add(&mut obj.id, key, value);
}

public fun get_field(obj: &MyObject, key: String): u64 {
    *df::borrow(&obj.id, key)
}
```

## Advanced Patterns

### Generic Types

```move
public struct Container<T: store> has key, store {
    id: UID,
    item: T,
}

public entry fun create_container<T: store>(
    item: T,
    ctx: &mut TxContext
) {
    let container = Container {
        id: object::new(ctx),
        item,
    };
    transfer::transfer(container, tx_context::sender(ctx));
}
```

### Events

```move
use sui::event;

public struct ItemCreated has copy, drop {
    id: ID,
    creator: address,
    name: String,
}

public entry fun create_item(name: String, ctx: &mut TxContext) {
    let item = Item {
        id: object::new(ctx),
        name,
    };

    event::emit(ItemCreated {
        id: object::id(&item),
        creator: tx_context::sender(ctx),
        name,
    });

    transfer::transfer(item, tx_context::sender(ctx));
}
```

### Error Handling

```move
const E_INVALID_VALUE: u64 = 1;
const E_UNAUTHORIZED: u64 = 2;

public entry fun update_value(
    obj: &mut MyObject,
    new_value: u64,
    ctx: &mut TxContext
) {
    assert!(new_value > 0, E_INVALID_VALUE);
    assert!(tx_context::sender(ctx) == obj.owner, E_UNAUTHORIZED);

    obj.value = new_value;
}
```

## Best Practices

### 1. Access Control

```move
public struct AdminCap has key {
    id: UID,
}

public entry fun admin_only_action(
    _: &AdminCap,
    // ... other parameters
) {
    // Only callable by admin
}
```

### 2. Input Validation

```move
public entry fun create_user(name: String, age: u8, ctx: &mut TxContext) {
    assert!(string::length(&name) > 0, E_EMPTY_NAME);
    assert!(age >= 18, E_TOO_YOUNG);

    // Create user...
}
```

### 3. Gas Optimization

- Use `entry` functions for user-called functions
- Minimize storage operations
- Use events instead of storing large amounts of data

## Common Patterns in Sui Move

### 1. NFT Creation

```move
public struct MyNFT has key, store {
    id: UID,
    name: String,
    description: String,
    url: Url,
}

public entry fun mint_nft(
    name: String,
    description: String,
    url: Url,
    ctx: &mut TxContext
) {
    let nft = MyNFT {
        id: object::new(ctx),
        name,
        description,
        url,
    };
    transfer::transfer(nft, tx_context::sender(ctx));
}
```

### 2. Token Implementation

```move
public struct TreasuryCap has key {
    id: UID,
    total_supply: u64,
}

public struct Coin has key, store {
    id: UID,
    balance: u64,
}

public entry fun mint(
    treasury: &mut TreasuryCap,
    amount: u64,
    recipient: address,
    ctx: &mut TxContext
) {
    treasury.total_supply = treasury.total_supply + amount;

    let coin = Coin {
        id: object::new(ctx),
        balance: amount,
    };

    transfer::transfer(coin, recipient);
}
```

## Testing Your Move Code

```move
#[test_only]
module my_addr::my_module_tests {
    use my_addr::my_module::{Self, MyStruct};
    use sui::test_scenario as ts;

    #[test]
    fun test_create_struct() {
        let scenario = ts::begin(@0x1);

        ts::next_tx(&mut scenario, @0x1);
        {
            my_module::create_my_struct(42, ts::ctx(&mut scenario));
        };

        ts::next_tx(&mut scenario, @0x1);
        {
            let struct = ts::take_from_sender<MyStruct>(&scenario);
            assert!(my_module::get_value(&struct) == 42, 0);
            ts::return_to_sender(&scenario, struct);
        };

        ts::end(scenario);
    }
}
```

## Deployment and Interaction

### Building and Deploying

```bash
# Build the package
sui move build

# Publish to devnet
sui client publish --gas-budget 10000000
```

### Interacting with Contracts

```typescript
import { SuiClient, getFullnodeUrl } from '@mysten/sui/client';

const client = new SuiClient({ url: getFullnodeUrl('devnet') });

// Call a function
const result = await client.moveCall({
  packageObjectId: '0x...',
  module: 'my_module',
  function: 'create_my_struct',
  typeArguments: [],
  arguments: [42],
  gasBudget: 10000,
});
```

## Conclusion

Sui Move combines the safety and expressiveness of the Move language with Sui's innovative object model. By understanding these concepts, you can build secure, efficient, and powerful smart contracts on the Sui blockchain.

Remember:
- Always validate inputs
- Use appropriate abilities
- Test thoroughly
- Follow established patterns
- Keep gas costs in mind

Happy coding with Sui Move! ðŸš€